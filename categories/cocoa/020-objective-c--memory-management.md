Objective-C : Memory Management
drypot 2010-12-21 20:02
iOS 에 접근하는데 Objective-C 의 다이나믹한 메시지 패싱 방법도 (C 계열에서) 생소한 것이지만
기괴한 메모리 관리 문화에 적응하는데도 일주일 이상 시간이 걸렸다.

문서 몇 장 보고 머리로는 이해가 되더라도
마음으로 받아들이는 데까지는 시간이 더 오래 걸리는 법이니까.

OS X 용 프로그램에는 가베지 컬렉터를 쓸 수 있으나 iOS 에서는 아직 사용할 수가 없다.
몇 년 안에 해주긴 하겠지만 그때까지 기다릴 수는 없으니,
당장 메모리 할당과 해제는 완전 수동으로 해야한다.

(2010 년에 이게 무슨 뚱딴지같은 상황이람)

어떻게 수동으로 관리하냐면,
일단, alloc 메시지로 생성되는 모든 오브젝트에 retain count 가 붙는다.

처음 alloc 할 때나 오브젝트를 copy 할 때 1 로 초기화 되고,
이 retain count 가 0 이 되면 메모리가 해제 된다.

오브젝트 소유권자가 추가로 생길 때마다 +1,
소유권자가 오브젝트를 release 할 때마다 -1 되어야 한다.

위에서 말했다시피 retain count 관리는 완전 수동이다. =,=
문화적인 룰이 있어서 이에 따라 주면 문제를 대부분 피할 수 있을 것 같긴 하지만,
코딩하다보면 실수는 하게 되어 있는데 이를 언어 문법 차원에서 방지해 주진 않는다.

그리고, retain count 만으로 해결할 수 없는 상황들이 발생하는데 이는 Autorealease Pool 스택으로 해결하고 있다.

Java 등에서는 주기적으로 오브젝트 레퍼런스 그래프를 훑어서 안 쓰는 오브젝트를 해제하지만,
Obj-C 에서는 당장은 써야하지만 미래의 어떤 시점에 해제해야할 오브젝트를 Autorelease Pool 에 넣어두었다가
후에 Autorelease Pool 을 파괴하면서 등록된 오브젝트들을 같이 정리한다.

당연하게도 Autorelease Pool 의 생성과 삭제(drain) 또한 완전 수동이다. =,=
iOS 의 경우는 아직 정확하게 모르겠으나,
App Kit 어플리케이션의 경우 마우스 이벤트 등이 발생할 때마다 Pool 이 생성되서
이벤트 처리시 만들어져 해제 위임된 오브젝트들을 짧은 주기로 정리할 수 있게 되어 있는 듯하다.

Pool 이 언제 필요하냐면,
메시지 리턴 값으로 오브젝트를 돌려주는 경우등에,

애플 문서를 보면 오브젝트는 생성한 곳에서 책임지고 해제하라고 되어 있는데
해제한 오브젝트를 리턴할 수 없고, 리턴해 버린 오브젝트는 영영 해제할 수 없는 것 아닌가.

이때 오브젝트를 만들어 넘기는 메서드에서 해제 풀에 오브젝트를 등록해 두면,
리턴된 오브젝트는 일정 기간 사용되다가 풀이 파괴되는 시점에 자동 해제 되는데,
결과적으로 오브젝트를 만든 곳에서 해제에 대한 책임을 완수한 것이 된다.

메모리 사고를 원천 방지하긴 어렵겠지만,
그래도 주어진 환경에서 그럴듯한 해법이긴 하다.