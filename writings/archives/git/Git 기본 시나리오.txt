Git 기본 시나리오


### 도움말

Git 명령에 관한 도움말을 본다.

	$ git help <verb>
	$ git <verb> --help
	$ man git-<verb>

예

	$ git help config


### 리포지터리 생성

워킹 디렉토리로 이동해서 리포지터리를 생성한다. 
 `.git` 라는 디렉토리가 생긴다.

	$ cd <project directory>
	$ git init

참고로 다른 리포지터리의 클론을 만들 수도 있다.
이 줄거리는 다른 글에서 이야기하기로 한다.

	$ git clone <source repository> <target directory>


### 인덱스에 파일 추가

커밋하려는 새 파일이나 커밋후 수정한 파일은 `git add` 명령으로 인덱스에 등록한다.

	$ git add <file>

특정 서브 디렉토리의 전체를 인덱싱할 수도 있다.

	$ git add <directory>

프로젝트 디렉토리의 전체를 인덱싱할 수도 있다.

	$ git add .


### 인덱싱 취소

인덱스에 스테이징한 것을 취소 하려면.

	$ git reset HEAD <file>
 

### 인덱스 확인

인덱스의 상태는 `git status` 명령으로 볼 수 있다.

	$ git status

인덱스에 등록된 파일 목록을 볼 수 있다.

	$ git ls-files -s

오브젝트 스토어의 파일을 꺼내 볼 수도 있다.

	$ git cat-file -p <object id>


### 커밋

현재 인덱스 내용을 커밋한다. 다르게 말하면 새로운 트리 오브젝트와 커밋 오브젝트를 생성한다.
`-m` 옵션은 필수다.

	$ git commit -m “first commit”

`-a` 옵션으로 수정된 파일들의 인덱싱과 커밋을 한번에 할 수도 있다. 즉 `git add + git commit` 이다. 
새로 만든 파일은 대상이 안 된다.

	$ git commit -a -m “commit all modified” 

바로 이전 커밋의 메시지를 수정하거나 파일을 추가할 수 있다.

	$ git commit --amend
 

### 파일 삭제

워킹 디렉토리 파일을 삭제하면서 인덱스에도 파일 삭제 명령을 스테이징한다.

	$ git rm <file>

기본 `git rm` 명령은 커밋 안 된 파일이 삭제되는 것을 막기 위해
지우려는 파일이 HEAD 내용과 일치하지 않으면 오류를 낸다.
이때 수정하던 파일을 강제삭제하려면 `-f` 를 붙여주어야 한다.

	$ git rm -f <file>

워킹 디렉토리의 파일은 그대로 두고 인덱스에서만 삭제하려면, 

	$ git rm --cached <file>

물론 `git rm` 을 실행하고 `git commit` 해야 오브젝트 스토어가 업데이트 된다.


### 파일 이동

이렇게 할 수도 있고,

	$ mv foo.html bar.html
	$ git rm foo.html
	$ git add bar.html

다음 명령으로 간단히 할 수도 있다.

	$ git mv foo.html bar.html


### 파일 복구

실수로 지운 파일을 최신 커밋에서 복구한다.

	$ git checkout HEAD -- <file> 


### 커밋 히스토리 확인

커밋 히스토리를 보여준다.

	$ git log

간단하고 이쁘게 보여준다.

	$ git log --pretty=oneline

범위를 지정할 수도 있다.
첫 글의 Relative Commit Names 가 기억나는가?

	$git log master~12..master~10
	
출력 갯 수를 지정할 수도 있다.
	
	$git log -5

특정 파일의 이력을 확인할 수도 있다.

	$ git log --follow <file>


### 개별 커밋 확인

최신 커밋의 상세 정보를 보여준다.

	$ git show

개별 커밋의 상세 정보를 보여준다.

	$ git show <commit>

커밋내 특정 파일 내용을 볼 수 있다.

	$ git show origin/master:Makefile

심볼릭 이름에 대한 커밋 ID 를 찾을 수 있다.

	$ gir rev-parse <symbolic commit name>


### 커밋간 차이 확인

	$ git diff <older commit id> <newer commit id>


### 파일 무시

컴파일러 출력 파일등 Git 로 관리할 필요가 없는 파일들이 많을 것이다.
이런 파일들의 패턴은 `.gitignore` 파일에서 관리한다.
서브디렉토리의 `.gitignore` 는 상위 규정을 오버라이딩한다. 
`.gitignore` 파일은 자동으로 `git add` 되지 않으니 수동으로 넣는다.

로컬 리포지터리에만 적용하고 싶은 예외 규정은 `.git/info/exclude` 에서 설정한다.
리포지터리 클론시 복사되지 않는다.

아래는 `.gitignore` 파일 예.

	# 이 줄은 코멘트.
	# 패턴 앞에 ! 을 붙이면 not 의 의미다

	# 빈 줄은 무시된다.

	# 파일 이름만 써놓으면 모든 디렉토리에서 해당 파일을 무시한다.
	ignore-me-everywhere.txt
	
	# OSX 에서는 폴터 관리 파일도 무시하자.
	.DS_Store

	# 끝이 / 로 끝나면 해당 디렉토리 전체를 무시한다.
	ignore-dir/

	# 와일드카드를 쓸 수도 있다.
	debug/32bit/*.o
	*.[oa]
	tmp/**/*
	log/*

	# 개발시 로컬 머신에서만 의미있는 설정 파일들도 무시한다
	config/database.yml


### 태깅

특정 커밋에 태그를 붙여 놓을 수 있다.
태그는 심볼 레퍼런스로 구현하는 경량 태그와 오브젝트 스토어에 저장하는 (Annotated) 태그가 있다.

태그 목록을 보여 준다.

	$ git tag

패턴으로 검색할 수도 있다.

	$ git tag -l ‘v.1.4.2.*’

경량 태그를 생성한다.
	
	$ git tag v1.4-lw

Annotated 태그를 생성하려면 `-a` 옵션을 사용한다.

	$ git tag -a v1.4 -m “version 1.4”

태그가 가리키는 커밋을 보여준다

	$ git show <tag>

리모트 리포지터리에 태그 정보를 보내려면 `--tags` 옵션을 사용해야 한다.

	$ git push <remote> --tags

