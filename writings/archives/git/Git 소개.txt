Git 소개


Git 명령에 대한 설명은 차후 이어지는 글에서 하기로 하고
이 글에서는 소개와 작동 방식에 대한 개괄을 보기로 한다.


### Git 소개

Git 는 분산형 버전 컨트롤 시스템 (DVCS) 이다.
버전 컨트롤 시스템은 프로젝트 파일들의 변화를 관리한다.
여기에 분산형이라는 말은 메인 리포지터리가 여러 곳에 존재할 수 있다는 뜻이다.
작업은 각자 자기 컴퓨터의 로컬 리포지터리에 저장하고 필요한 시점에 리포지터리들을 병합한다.


### Git 의 시작

2005 년,  4 월 3 일, 토발즈는  Git 를 만들기 시작한다.  
4 월 7 일, Git 는 스스로를 호스팅한다.  
4 월 18 일, 다중 브랜치 머지까지 완성되었다.  
6 월 16 일, Git 로 관리된 첫 리눅스 커널이 릴리즈된다.

보다시피 Git 는 한 달도 안 되서 뚝딱 만들어 졌다.
Git 가 매우 복잡한 구현을 가지고 있으리라 상상하겠지만 그 반대다.
Git 는 재밋는 상상력을 통해 복잡한 문제에 명쾌한 해법을 제시하는 간단한(?) 도구들의 집합이다.

VCS 가 대처해야 하는 상황 자체가 복잡하다보니 동작에 의문점이 많을 수 있고
문제를 해결하는데 기존 VCS 들과 매우 다른 방식으로 접근해서 생소할 수도 있지만
기존 VCS 들이 해결하기 어려웠던 문제들까지 상대적으로 간단한 방법의 해법을 제시한다.


### Git 의 기본 특징

SVN 등의 VCS 는 파일 목록과 버전간 파일 내용의 차이를 관리했지만
Git 는 각 버전 파일들의 이미지를 원형 그대로 통으로 저장한다.
이전에 저장했던 파일이 변경되지 않았다면 중복 저장하지 않고 그에 대한 링크를 활용한다.
Git 는 이 특성으로 다른 VCS 들이 가지지 못한 여러가지 잇점을 얻게 되었다.

Git 는 거의 모든 작업을 로컬 리포지터리에서 한다.
프로젝트 생성 직후 부터 기록된 모든 기록을 로컬에 일단 복사하므로 다른 VCS 들에 비해 동작들이 매우 빠르다.
커밋 또한 로컬에 하니 네트웍에 연결되어 있을 필요가 없다.
변경 사항들을 모아 올리거나 내려받아 머지할 때만 외부 리포지터리에 접근하면 된다.

아래에 보게 되겠지만 Git 는 리포지터리의 모든 파일과 디렉토리 정보에 SHA1 해쉬값을 키로 접근한다.
그러므로 구조적으로 리포지터리의 데이터 변조가 거의 불가능하다.

Git 가 관리할 소스 파일들이 들어있는 디렉토리를 워킹 디렉토리라고 한다.
파일의 추가, 수정, 삭제는 워킹 디렉토리에서 이루어 진다.

다른 VCS 에서 커밋 한번에 하는 작업을 Git 에서는 인덱싱과 커밋의 두 단계로 나누어 한다.
워킹 디렉토리와 오브젝트 스토어 중간에 있는 인덱스는 커밋할 내용을 임시로 모으는 곳으로
커밋할 내용은 인덱스에 명시적으로 등록해야 한다.
파일이 변경되었다 하더라도 인덱싱하지 않으면 커밋시 리포지터리에 저장되지 않는다.
참고로 인덱싱을 스테이징으로, 인덱스를 스테이징 영역으로 칭하는 문서들도 많다.


### 리포지터리

리포지터리는 Git 의 핵심으로 변경을 유지하고 관리하는데 사용되는 데이터베이스다.
워킹 디렉토리 루트에 만들어지는 .git 라는 숨겨진 디렉토리가 리포지터리다.

Git 는 분산 VCS 다. 그래서, 다른 VCS 들과 다르게 리포지터리 클론이 가능하다.
단, 설정 파일은 각 로컬에 독립적이어서 클론되지 않는다.

리포지터리에는 코드 공유 용도로 사용되는 bare 리포지터리와 일반 개발 리포지터리가 있다.
bare 리포지터리는 오브젝트 스토어만 있을 뿐 워킹 디텍토리가 따로 없다.
개발 리포지터리에 대해서도 push/pull 을 할 수는 있지만 워킹 디렉토리와 관련해 골치아픈 문제들을 만들게 되므로
코드 공유를 위해서는 중앙에 bare 리포지터리를 운영하는 것이 좋다.

Git 리포지터리에는 오브젝트 스토어와 인덱스, 두 개의 주요 데이터 구조가 있다.
오브젝트 스토어는 리포지터리의 핵심이고
오브젝트 스토어에 커밋할 내용을 임시로 저장하는 곳이 인덱스다.

Git 는 파일 내용의 SHA1 해쉬를 파일의 이름으로 사용한다.
리포지터리 구조를 보기 전에 이 특징을 보고 넘어 간다.


### SHA1 파일명

오브젝트 스토어에 저장되는 모든 파일들은 내용의 SHA1 해쉬가 이름이 된다.
SHA1 해쉬는 20 byte 또는 40 문자로 구성되는 16 진수 숫자열이다.
블롭, 트리, 커밋, 태그 파일 모두 SHA1 해쉬를 이름으로 갖는다.

원래 파일명과 해쉬 생성 기계에 상관 없이 파일 내용이 같으면 SHA1 해쉬값은 같다.
SHA1 해쉬가 같은 파일들은 한 벌만 저장된다.

이름 대신 SHA1 해쉬를 쓰므로 커밋이 겹겹이 쌓인 상태에서도 SHA1 해쉬만 가지고 특정 버전의 파일을 쉽게 가리킬 수 있다.
해쉬만으로 동일여부를 판단하므로 매우 큰 오브젝트들의 존재 유무를 데이터 전송없이 알아낼 수 있다. 
트리 오브젝트의 해쉬가 같다면 서브 디렉토리 모든 파일을 비교하지 않고도 두 디렉토리 내용이 같다는 보장을 얻을 수 있다.
파일 내용이 파일명에 드러나고 그러한 파일명이 트리 오브젝트에도 저장되기 때문에
트리 오브젝트의 해쉬는 서브 디렉토리 전체의 내용을 반영한다.

내용이 다른 파일간 SHA1 해쉬가 충돌할 가능성은 있다. 하지만 엄청나게 낮다.
충돌나면 어떻게 되는지에 대한 말은 안 보인다. =,=

Git 리포지터리는 오브젝트 스토어와 인덱스로 구성된다.


### 오브젝트 스토어

기록에 관해 상상할 수 있는 모든 것은 여기에 저장된다.
파일 시스템상의 평범한 디렉토리다.
오브젝트 스토어 구조는 리포지터리를 효율적으로 클론할 수 있도록 만들어졌다.
오브젝트 스토어에 저장되는 오브젝트는 딱 네 종류다.

블롭,

파일의 버젼들은 블롭으로 저장된다.
블롭에는 파일 데이터만 저장된다. 파일 이름은 저장되지 않는다.
Git 는 diff 결과를 저장하지 않는다. 모든 파일의 모든 버전들을 원본 그대로 저장한다.
diff 는 필요할 때마다 계산해서 표시한다.
블롭은 데이터 구조의 최하단에 있으며 다른 오브젝트에 대한 링크를 갖지 않는다.

트리,

블롭의 해쉬, 패스, 기타 메타 정보가 기록된다.
트리 오브젝트는 다른 트리나 블롭에 대한 링크를 갖는다.

커밋,

커밋 오브젝트에는 커밋 메타 데이터와 커밋 과정에서 만들어진 루트 트리의 링크가 저장된다.
커밋은 이전 커밋에 대한 링크를 가진다.
머지의 결과로 만들어진 커밋은 여러 부모 커밋을 갖는다.
서로 다른 커밋 오브젝트가 같은 트리에 대한 링크를 가질 수 있다.

태그,

커밋에 사람이 읽기 쉬운 이름을 달기 위해 사용한다.


### 인덱스

인덱스는 커밋할 내용을 임시 저장하는 비공개 스토리지다.
좀더 구체적으로 표현하면 커밋시 트리 오브젝트를 만드는데 필요한 정보를 임시 저장하는 버퍼다.
파일에 대한 블롭 오브젝트는 파일이 인덱스에 등록될 때 미리 생성하고 
트리 오브젝트는 인덱스를 가지고 커밋시 생성한다.
클론시 인덱스는 복사되지 않는다.

참고로 커밋 전에 한 파일을 여러번 인덱싱하면 고아 노드가 발생한다.
<http://stackoverflow.com/questions/1341675/multiple-git-add-before-git-commit>


### 기본 작동 시나리오

Git 스토리지 구조를 알았으니 기본 작동 시나리오를 보자.

새 리포지터리는 두 가지 방식으로 만들 수 있다.
로컬 머신이나 외부 머신의 기존 리포지터리를 클론할 수도 있고 현재 디렉토리에 새 리포지터리를 만들 수도 있다.
현재 디렉토리에 새 리포지터리를 만들려면 `git init` 명령을 사용한다.
안 보이는 `.git` 디렉토리가 생긴다.

새로 트래킹할 파일이나 커밋 후 수정한 파일은 `git add` 명령으로 인덱스에 등록한다.
`git add`  는 오브젝트 스토어에 파일에 대한 블롭을 생성하고 인덱스를 업데이트 한다.
인덱스 파일이 파일명과 블롭의 연결을 관리한다.
트리는 아직 생성되지 않는다. 

`git add, rm, mv` 명령을 내릴 때마다 인덱스가 업데이트된다.

코딩작업의 한 단위가 끝났으면 `git commit` 명령으로 커밋한다.
커밋은 새로운 트리 오브젝트와 커밋 오브젝트를 만드는 일이다.
블롭들의 변화에 따라 트리들이 추가될 수도 있고 기존 것들이 재사용될 수도 있다.
새 커밋 오브젝트는 바로 이전 커밋에 대한 링크를 갖고 브랜치는 새로 생성된 커밋의 링크를 갖도록 업데이트된다.

다음은 앞으로 Git 문서를 보다 자주 만나게 될 Symref 와 Relative Commit Names 에 대한 간략한 설명이다.
먼저 매맞는 마음으로 간단히 보고 넘어가는 것이 좋을 것이다.


### 심볼

Git 를 쓰다보면 많은 커밋 오브젝트를 만들게 되는데 20 자리 16진수 이름을 직접다루는 것은 불편하다.
그래서 해쉬 이름을 대신하는 심볼 (symref, Symbolic reference) 을 사용한다.

심볼은 아래 모든 디렉토리들에서 검색되기 때문에 긴 이름을 쓸 수도 있고 짧게 줄여 쓸 수도 있다.
예로, `dev` 는 `refs/heads/dev` 의 짧은 이름이 될 수 있고
`origin/master` 는 `refs/remotes/origin/master` 의 짧은 이름이 될 수 있다. 

	.git/<ref name>
	.git/refs/<ref name>
	.git/refs/tags/<ref name>
	.git/refs/heads/<ref name>
	.git/refs/remotes/<ref name>
	.git/refs/remotes/<ref name>/HEAD

심볼은 몇 가지 상위 개념을 구현하는데 사용된다.
과거의 특정 커밋을 지칭하기 위해서는 태그를 사용하고 일련의 커밋 리스트를 다루기 위해서는 브랜치를 사용하는데
브랜치가 여러 명령에 의해 자동 업데이트 된다는 차이가 있을 뿐 태그와 브랜치가 특정 커밋을 가리키는 심볼이라는 점에선 같다.

`.git` 디렉토리에서는 맨 처음 규칙을 만족시키는 `HEAD`, `ORIG_HEAD`, `FETCH_HEAD`, `MERGE_HEAD` 등의
특별한 심볼 파일들을 볼 수 있다. 이 심볼들은 Git 가 특별히 관리한다.

HEAD, 현재 브랜치의 최신 커밋을 가리킨다.

ORIG_HEAD, `merge` 나 `reset` 명령은 HEAD 를 ORIG_HEAD 라는 이름으로 백업해 둔다.

FETCH_HEAD, `git fetch` 명령은 fetch 한 모든 브랜치들의 HEAD 를 `.git/FETCH_HEAD` 에 저장한다.

MERGE_HEAD, merge 중 merge 하고 있는 다른 브랜치의 HEAD 가 MERGE_HEAD 에 저장된다.


### Relative Commit Names

브랜치 이름의 끝에 특수 문자를 붙여서 커밋을 지정하는 방법이 있다.

`master^` 는 master 브랜치 HEAD 의 부모 커밋을 가리킨다. `master~1` 도 같은 의미다.

`master^^` 는 master 브랜치 HEAD 의 부모의 부모 커밋을 가리킨다. `master~2` 도 같은 의미다.

머지는 여러 부모를 갖는데 머지로 생성된 `C` 라는 커밋이 있을  때
`C^1` 은 첫 번째 부모 커밋, `C^2` 는 두 번째 부모 커밋을 가리킨다.

